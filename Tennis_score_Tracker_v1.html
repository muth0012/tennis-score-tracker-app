<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tennis Match Tracker (Advanced No-Ad)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter Font -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .log-container {
            max-height: 300px;
            overflow-y: auto;
            scrollbar-width: thin;
        }
    </style>
</head>
<body class="p-4">

    <div id="app" class="w-full max-w-5xl bg-white shadow-2xl rounded-xl p-6 md:p-10 border border-gray-100">

        <!-- Header and Status -->
        <h1 class="text-3xl md:text-4xl font-extrabold text-gray-800 text-center mb-2 tracking-tight">
            Tennis Scoreboard (No-Ad)
        </h1>
        <p id="match-status" class="text-center text-lg mb-4 font-semibold text-green-600 transition duration-300">
            Initializing...
        </p>

        <!-- Match ID and Persistence Status -->
        <div class="mb-6 text-center text-sm text-gray-500 space-y-2">
            <p>
                <span class="font-bold">Match ID:</span> <span id="match-id-display">Loading...</span>
            </p>
            <p>
                <span class="font-bold">User ID:</span> <span id="user-id-display">Loading...</span>
            </p>
            <p id="save-status" class="font-medium text-gray-600">Awaiting user action...</p>
        </div>
        
        <!-- Scoreboard Table -->
        <div class="overflow-x-auto mb-8 border border-gray-200 rounded-lg">
            <table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-50">
                    <tr>
                        <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider md:w-1/5">Player</th>
                        <th class="px-3 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">Set 1</th>
                        <th class="px-3 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider hidden sm:table-cell">Set 2</th>
                        <th class="px-3 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider hidden sm:table-cell">Set 3</th>
                        <th class="px-3 py-3 text-center text-sm font-bold text-gray-700 uppercase tracking-wider w-1/4 bg-gray-200">Game Score</th>
                    </tr>
                </thead>
                <tbody class="bg-white divide-y divide-gray-200">
                    <!-- Player 1 Row -->
                    <tr>
                        <td id="p1-name" class="px-3 py-4 whitespace-nowrap text-sm font-medium text-gray-900">Player 1</td>
                        <td id="p1-set1" class="px-3 py-4 whitespace-nowrap text-sm text-center text-gray-700">0</td>
                        <td id="p1-set2" class="px-3 py-4 whitespace-nowrap text-sm text-center text-gray-700 hidden sm:table-cell">0</td>
                        <td id="p1-set3" class="px-3 py-4 whitespace-nowrap text-sm text-center text-gray-700 hidden sm:table-cell">0</td>
                        <td id="p1-game-score" class="px-3 py-4 whitespace-nowrap text-base font-bold text-center bg-green-50 text-green-700">Love</td>
                    </tr>
                    <!-- Player 2 Row -->
                    <tr>
                        <td id="p2-name" class="px-3 py-4 whitespace-nowrap text-sm font-medium text-gray-900">Player 2</td>
                        <td id="p2-set1" class="px-3 py-4 whitespace-nowrap text-sm text-center text-gray-700">0</td>
                        <td id="p2-set2" class="px-3 py-4 whitespace-nowrap text-sm text-center text-gray-700 hidden sm:table-cell">0</td>
                        <td id="p2-set3" class="px-3 py-4 whitespace-nowrap text-sm text-center text-gray-700 hidden sm:table-cell">0</td>
                        <td id="p2-game-score" class="px-3 py-4 whitespace-nowrap text-base font-bold text-center bg-red-50 text-red-700">Love</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- Point Logging Inputs and Undo -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6 p-4 border border-blue-200 bg-blue-50 rounded-lg">
            
            <!-- Point Type Selector -->
            <div>
                <label for="point-type" class="block text-sm font-medium text-gray-700 mb-1">Point Type</label>
                <select id="point-type" class="w-full px-4 py-2 border border-blue-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 bg-white">
                    <option value="W-G">Winner - Groundstroke (W-G)</option>
                    <option value="W-V">Winner - Volley (W-V)</option>
                    <option value="W-D">Winner - Drop Shot (W-D)</option>
                    <option value="UE">Unforced Error (UE)</option>
                    <option value="FE">Forced Error (FE)</option>
                    <option value="DF">Double Fault (DF)</option>
                </select>
            </div>

            <!-- Rally Length Input -->
            <div>
                <label for="rally-length" class="block text-sm font-medium text-gray-700 mb-1">Rally Length (# Shots)</label>
                <input type="number" id="rally-length" min="1" value="1"
                    class="w-full px-4 py-2 border border-blue-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
            </div>

            <!-- Control Buttons -->
            <div class="flex flex-col space-y-2 justify-end">
                <button onclick="undoLastPoint()" id="btn-undo" disabled
                    class="w-full py-2 bg-yellow-500 text-white font-semibold rounded-xl shadow-md hover:bg-yellow-600 transition duration-200 disabled:bg-gray-400 disabled:cursor-not-allowed">
                    Undo Last Point
                </button>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="flex flex-col md:flex-row gap-4 justify-between">
            <button onclick="recordPoint(1)" id="btn-p1" disabled
                class="flex-1 px-6 py-4 bg-green-500 text-white font-semibold text-lg rounded-xl shadow-md hover:bg-green-600 transition duration-200 transform hover:scale-[1.02] active:scale-[0.98] focus:outline-none focus:ring-4 focus:ring-green-300 disabled:opacity-50 disabled:cursor-not-allowed">
                Point for Player 1
            </button>
            <button onclick="recordPoint(2)" id="btn-p2" disabled
                class="flex-1 px-6 py-4 bg-red-500 text-white font-semibold text-lg rounded-xl shadow-md hover:bg-red-600 transition duration-200 transform hover:scale-[1.02] active:scale-[0.98] focus:outline-none focus:ring-4 focus:ring-red-300 disabled:opacity-50 disabled:cursor-not-allowed">
                Point for Player 2
            </button>
        </div>

        <!-- Point Log Section -->
        <div class="mt-8">
            <h3 class="text-xl font-bold text-gray-700 mb-4 border-b pb-2">Match History Log</h3>
            <div id="point-log" class="log-container space-y-2 p-3 bg-gray-50 rounded-lg border">
                <!-- Log entries will appear here -->
                <p class="text-sm text-gray-500">No points recorded yet. Hit a point button to start logging!</p>
            </div>
        </div>

        <!-- Reset Button -->
        <div class="mt-6 text-center">
            <button onclick="resetMatch()"
                class="w-full md:w-auto px-8 py-3 bg-gray-200 text-gray-800 font-medium rounded-lg shadow-sm hover:bg-gray-300 transition duration-200 focus:outline-none focus:ring-2 focus:ring-gray-400">
                Start New Match
            </button>
        </div>

        <!-- Input Modal (Hidden by Default) -->
        <div id="modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50">
            <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-sm">
                <h3 class="text-xl font-bold mb-4 text-gray-800" id="modal-title">Enter Names</h3>
                <div class="space-y-4">
                    <input type="text" id="p1-input" placeholder="Player 1 Name (e.g., Nadal)"
                        class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
                    <input type="text" id="p2-input" placeholder="Player 2 Name (e.g., Djokovic)"
                        class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
                </div>
                <button onclick="saveNames()"
                    class="mt-6 w-full px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition duration-200">
                    Start Match
                </button>
            </div>
        </div>

    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        setLogLevel('Debug');

        // Global variables provided by the environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db, auth, currentUserId;
        let unsubscribeMatchListener = null;

        // --- Game State Management ---
        let matchState = {
            p1Name: 'Player 1',
            p2Name: 'Player 2',
            sets: [
                { p1: 0, p2: 0 },
                { p1: 0, p2: 0 },
                { p1: 0, p2: 0 }
            ],
            currentSetIndex: 0,
            p1Points: 0,
            p2Points: 0,
            isTieBreak: false,
            tieBreakScore: { p1: 0, p2: 0 },
            matchStatus: 'Ongoing',
            maxSets: 3,
            history: [], // Stores previous full matchState objects for undo
            matchId: 'new-match', // Default ID, will be replaced by user ID or query param
            userId: null
        };

        const POINT_MAP = ['Love', '15', '30', '40'];
        const MATCH_COLLECTION = `artifacts/${appId}/public/data/tennis_matches`;

        // --- Firebase Initialization and Authentication ---

        async function initFirebase() {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Check for existing matchId in URL (optional feature for loading shared match)
                const urlParams = new URLSearchParams(window.location.search);
                const urlMatchId = urlParams.get('matchId');
                
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        currentUserId = user.uid;
                        document.getElementById('user-id-display').textContent = currentUserId;
                        matchState.userId = currentUserId;
                        
                        // Decide on matchId: Use URL, or default to user's new match ID
                        matchState.matchId = urlMatchId || currentUserId;
                        document.getElementById('match-id-display').textContent = matchState.matchId;

                        setupRealtimeListener();
                        // Only show modal if match state is still default
                        if (matchState.p1Name === 'Player 1' && !urlMatchId) {
                            showModal();
                        }
                        enableButtons();
                    } else {
                        console.error("Authentication failed: User is null after sign-in.");
                        document.getElementById('match-status').textContent = 'Error: Authentication failed.';
                    }
                });

            } catch (error) {
                console.error("Firebase initialization failed:", error);
                document.getElementById('match-status').textContent = `Error: DB Init Failed. ${error.message}`;
            }
        }

        // --- Data Persistence (Firestore) ---

        function setupRealtimeListener() {
            if (unsubscribeMatchListener) {
                unsubscribeMatchListener(); // Clean up previous listener
            }

            const docRef = doc(db, MATCH_COLLECTION, matchState.matchId);

            unsubscribeMatchListener = onSnapshot(docRef, (docSnap) => {
                if (docSnap.exists() && docSnap.id === matchState.matchId) {
                    const data = docSnap.data();
                    // Load data only if it was saved by a different user OR if it's the first load
                    if (data.userId !== matchState.userId || matchState.p1Name === 'Player 1') {
                        loadMatchState(data);
                        updateMatchStatus(`Match loaded from database! ID: ${matchState.matchId}`);
                    }
                } else {
                    // Document doesn't exist, save the current default state to create it
                    saveMatchState();
                    updateMatchStatus('New match document created.');
                }
            }, (error) => {
                console.error("Firestore listen failed:", error);
                document.getElementById('save-status').textContent = `DB Error: ${error.message}`;
            });
        }

        async function saveMatchState() {
            if (!db || !matchState.matchId) return;

            const docRef = doc(db, MATCH_COLLECTION, matchState.matchId);
            const stateToSave = {
                ...matchState,
                // Simplify history for saving (only keep last 100 entries to prevent document size issues)
                history: matchState.history.slice(-100), 
                lastUpdated: Date.now(),
                userId: currentUserId // Record who last updated it
            };

            try {
                document.getElementById('save-status').textContent = 'Saving...';
                await setDoc(docRef, stateToSave);
                document.getElementById('save-status').textContent = 'Saved!';
            } catch (e) {
                console.error("Error saving document: ", e);
                document.getElementById('save-status').textContent = `Save Error: ${e.message}`;
            }
        }

        function loadMatchState(data) {
            // Apply all non-function properties from data to matchState
            Object.keys(data).forEach(key => {
                if (key in matchState) {
                    matchState[key] = data[key];
                }
            });
            // Ensure necessary fields are initialized if missing from old saved data
            matchState.sets = matchState.sets || [{ p1: 0, p2: 0 }, { p1: 0, p2: 0 }, { p1: 0, p2: 0 }];
            matchState.history = matchState.history || [];
            matchState.isTieBreak = matchState.isTieBreak || false;
            matchState.tieBreakScore = matchState.tieBreakScore || { p1: 0, p2: 0 };
            
            checkMatchEnd(); // Re-check if match is over
            render();
        }

        // --- Core Scoring Logic ---

        /**
         * Converts numerical point score to tennis text score using NO-AD rules, supporting Tie-Break.
         */
        function getGameScoreText(p1, p2) {
            if (matchState.isTieBreak) {
                // Tie-break scores are numerical
                return [p1.toString(), p2.toString()];
            }

            // Game End (No-Ad)
            if (p1 === 4) return ['WINS', ''];
            if (p2 === 4) return ['', 'WINS'];

            // Deciding Point (Deuce in No-Ad)
            if (p1 === 3 && p2 === 3) return ['Deciding Point', 'Deciding Point'];

            // Normal score
            const p1Text = POINT_MAP[p1];
            const p2Text = POINT_MAP[p2];
            return [p1Text, p2Text];
        }

        /**
         * Handles a game win, resets points, and checks for set win.
         */
        function handleGameWin(winner) {
            const currentSet = matchState.sets[matchState.currentSetIndex];

            if (winner === 1) {
                currentSet.p1++;
            } else {
                currentSet.p2++;
            }

            // Reset game points
            matchState.p1Points = 0;
            matchState.p2Points = 0;

            // Exit tie-break mode if we were in one
            matchState.isTieBreak = false;
            matchState.tieBreakScore = { p1: 0, p2: 0 };

            // Check for set win and match win
            checkSetWin();

            if (matchState.matchStatus === 'Ongoing') {
                updateMatchStatus(`Game for ${matchState['p' + winner + 'Name']}.`);
            }
        }
        
        /**
         * Handles a tie-break point win and checks for tie-break set win.
         * @param {number} winner - 1 or 2
         */
        function handleTieBreakPoint(winner) {
            const tb = matchState.tieBreakScore;

            if (winner === 1) {
                tb.p1++;
            } else {
                tb.p2++;
            }

            // Tie-break win rules: First to 7, must win by 2
            if ((tb.p1 >= 7 && tb.p1 >= tb.p2 + 2) || (tb.p2 >= 7 && tb.p2 >= tb.p1 + 2)) {
                handleGameWin(winner); // This implicitly handles the set win and advances to next set
                updateMatchStatus(`Tie-break won by ${matchState['p' + winner + 'Name']}!`);
            }
        }

        /**
         * Checks if the current set is won or if a tie-break is needed.
         */
        function checkSetWin() {
            const currentSet = matchState.sets[matchState.currentSetIndex];
            const p1G = currentSet.p1;
            const p2G = currentSet.p2;

            let setWinner = null;

            // Set win rules: Win by 2 games.
            if (p1G >= 6 && p1G >= p2G + 2) {
                setWinner = 1;
            } else if (p2G >= 6 && p2G >= p1G + 2) {
                setWinner = 2;
            }

            // Tie-break rule: If 6-6, start tie-break game
            if (!setWinner && p1G === 6 && p2G === 6) {
                matchState.isTieBreak = true;
                updateMatchStatus('The set is tied at 6-6. Entering Tie-Break Mode!');
            }

            if (setWinner) {
                // Set is won.
                updateMatchStatus(`Set ${matchState.currentSetIndex + 1} won by ${matchState['p' + setWinner + 'Name']} (${p1G}-${p2G})!`);
                checkMatchEnd();

                // Advance to the next set if available and match is not over
                if (matchState.matchStatus === 'Ongoing' && matchState.currentSetIndex < matchState.maxSets - 1) {
                    matchState.currentSetIndex++;
                }
            }
        }

        /**
         * Checks if the match has been won.
         */
        function checkMatchEnd() {
            const p1SetsWon = matchState.sets.filter(set => set.p1 > set.p2 && set.p1 >= 6).length;
            const p2SetsWon = matchState.sets.filter(set => set.p2 > set.p1 && set.p2 >= 6).length;

            if (p1SetsWon === 2 || p2SetsWon === 2) {
                matchState.matchStatus = (p1SetsWon === 2) ? `${matchState.p1Name} WINS THE MATCH!` : `${matchState.p2Name} WINS THE MATCH!`;
                updateMatchStatus(matchState.matchStatus, 'match-end');
                disableButtons();
            } else {
                 matchState.matchStatus = 'Ongoing';
                 enableButtons();
            }
        }


        /**
         * Main function to handle a point scored by a player, including logging.
         */
        window.recordPoint = function(winner) {
            if (matchState.matchStatus.includes('WINS THE MATCH')) return;

            // 1. Save current state to history for undo
            matchState.history.push(JSON.parse(JSON.stringify(matchState)));
            document.getElementById('btn-undo').disabled = false;

            // 2. Get logging details
            const pointType = document.getElementById('point-type').value;
            // Ensure rally length is a positive integer
            const rallyLength = Math.max(1, parseInt(document.getElementById('rally-length').value) || 1);

            let winnerName = matchState[`p${winner}Name`];
            let pointDescription;

            // 3. Apply point logic
            if (matchState.isTieBreak) {
                handleTieBreakPoint(winner);
                pointDescription = `Point in Tie-Break`;
            } else {
                // No-Ad game scoring
                if (winner === 1) {
                    matchState.p1Points++;
                } else {
                    matchState.p2Points++;
                }
                
                // NO-AD SCORING RULE
                if (matchState.p1Points === 4) {
                    handleGameWin(1);
                } else if (matchState.p2Points === 4) {
                    handleGameWin(2);
                }
                pointDescription = `Point (${POINT_MAP[matchState.p1Points] || 'Game End'}-${POINT_MAP[matchState.p2Points] || 'Game End'})`;
            }

            // 4. Log the point
            const logEntry = {
                id: Date.now(),
                winner: winner,
                name: winnerName,
                type: pointType,
                rallyLength: rallyLength,
                description: pointDescription
            };
            
            // The full log is in the history array, but we can also display a simple running log
            displayLogEntry(logEntry);

            // 5. Render and save
            render();
            saveMatchState();
        }

        /**
         * Reverts the match state to the previous step in history.
         */
        window.undoLastPoint = function() {
            if (matchState.history.length === 0) return;

            const previousState = matchState.history.pop();
            
            // Deep copy the previous state back to the current state
            Object.keys(previousState).forEach(key => {
                matchState[key] = previousState[key];
            });

            // Remove the last entry from the display log
            const logEl = document.getElementById('point-log');
            if (logEl.firstChild && logEl.firstChild.tagName !== 'P') {
                logEl.removeChild(logEl.firstChild);
            }
            if (logEl.children.length === 0) {
                 logEl.innerHTML = '<p class="text-sm text-gray-500">No points recorded yet. Hit a point button to start logging!</p>';
            }

            // Disable undo if history is empty
            if (matchState.history.length === 0) {
                document.getElementById('btn-undo').disabled = true;
            }

            checkMatchEnd();
            updateMatchStatus('Last point undone.');
            render();
            saveMatchState();
        }
        
        // --- UI Rendering ---

        /**
         * Renders the current state to the DOM.
         */
        function render() {
            document.getElementById('p1-name').textContent = matchState.p1Name;
            document.getElementById('p2-name').textContent = matchState.p2Name;

            // Set Scores
            document.getElementById('p1-set1').textContent = matchState.sets[0].p1;
            document.getElementById('p2-set1').textContent = matchState.sets[0].p2;
            document.getElementById('p1-set2').textContent = matchState.sets[1].p1;
            document.getElementById('p2-set2').textContent = matchState.sets[1].p2;
            document.getElementById('p1-set3').textContent = matchState.sets[2].p1;
            document.getElementById('p2-set3').textContent = matchState.sets[2].p2;

            // Current Game Score
            let p1CurrentPoints, p2CurrentPoints;
            if (matchState.isTieBreak) {
                p1CurrentPoints = matchState.tieBreakScore.p1;
                p2CurrentPoints = matchState.tieBreakScore.p2;
            } else {
                p1CurrentPoints = matchState.p1Points;
                p2CurrentPoints = matchState.p2Points;
            }

            const [p1Text, p2Text] = getGameScoreText(p1CurrentPoints, p2CurrentPoints);

            const p1GameEl = document.getElementById('p1-game-score');
            const p2GameEl = document.getElementById('p2-game-score');

            p1GameEl.textContent = p1Text;
            p2GameEl.textContent = p2Text;

            // Highlight Game Score based on status
            p1GameEl.classList.remove('bg-yellow-50', 'text-yellow-700', 'bg-red-50', 'text-red-700', 'bg-green-50', 'text-green-700', 'bg-gray-200', 'text-gray-800');
            p2GameEl.classList.remove('bg-yellow-50', 'text-yellow-700', 'bg-red-50', 'text-red-700', 'bg-green-50', 'text-green-700', 'bg-gray-200', 'text-gray-800');

            if (p1Text === 'Deciding Point' || p2Text === 'Deciding Point') {
                p1GameEl.classList.add('bg-gray-200', 'text-gray-800');
                p2GameEl.classList.add('bg-gray-200', 'text-gray-800');
            } else if (matchState.isTieBreak) {
                 p1GameEl.classList.add('bg-yellow-50', 'text-yellow-700');
                 p2GameEl.classList.add('bg-yellow-50', 'text-yellow-700');
            } else {
                p1GameEl.classList.add('bg-green-50', 'text-green-700');
                p2GameEl.classList.add('bg-red-50', 'text-red-700');
            }
            
            // Re-apply "Point for Player X" text to buttons after rendering names
            document.getElementById('btn-p1').textContent = `Point for ${matchState.p1Name}`;
            document.getElementById('btn-p2').textContent = `Point for ${matchState.p2Name}`;

            // Handle undo button state
            document.getElementById('btn-undo').disabled = matchState.history.length === 0 || matchState.matchStatus.includes('WINS THE MATCH');
        }

        /**
         * Displays a new entry in the point log.
         */
        function displayLogEntry(entry) {
            const logEl = document.getElementById('point-log');
            // Remove initial placeholder text
            if (logEl.firstChild && logEl.firstChild.tagName === 'P') {
                 logEl.innerHTML = '';
            }

            const logItem = document.createElement('div');
            logItem.className = `p-2 rounded-lg text-sm transition-all duration-300 ${entry.winner === 1 ? 'bg-green-100 border-l-4 border-green-500' : 'bg-red-100 border-l-4 border-red-500'}`;
            
            // Updated Point Name Map
            const pointNameMap = { 
                'W-G': 'Winner (Groundstroke)', 
                'W-V': 'Winner (Volley)', 
                'W-D': 'Winner (Drop Shot)', 
                'UE': 'Unforced Error', 
                'FE': 'Forced Error', 
                'DF': 'Double Fault' 
            };

            logItem.innerHTML = `
                <div class="flex justify-between font-semibold">
                    <span>${entry.name} Scores: ${entry.description}</span>
                    <span class="text-xs font-normal text-gray-600">${new Date().toLocaleTimeString()}</span>
                </div>
                <div class="text-xs mt-1">
                    Type: <span class="font-bold">${pointNameMap[entry.type]} (${entry.type})</span> | 
                    Rally: <span class="font-bold">${entry.rallyLength} shots</span>
                </div>
            `;
            
            // Add the newest entry to the top
            logEl.prepend(logItem);
        }

        /**
         * Updates the match status message with an optional type (used for styling).
         */
        function updateMatchStatus(message, type = 'normal') {
            const statusEl = document.getElementById('match-status');
            statusEl.textContent = message;
            statusEl.classList.remove('text-green-600', 'text-red-600', 'text-indigo-600', 'text-2xl', 'font-extrabold');
            if (type === 'match-end') {
                statusEl.classList.add('text-indigo-600', 'text-2xl', 'font-extrabold');
            } else {
                statusEl.classList.add('text-green-600');
            }
        }

        /**
         * Resets the match state, generates a new match ID, and prompts for new names.
         */
        window.resetMatch = function() {
            matchState = {
                p1Name: 'Player 1',
                p2Name: 'Player 2',
                sets: [
                    { p1: 0, p2: 0 },
                    { p1: 0, p2: 0 },
                    { p1: 0, p2: 0 }
                ],
                currentSetIndex: 0,
                p1Points: 0,
                p2Points: 0,
                isTieBreak: false,
                tieBreakScore: { p1: 0, p2: 0 },
                matchStatus: 'Ongoing',
                maxSets: 3,
                history: [],
                // New random match ID for a new match
                matchId: currentUserId + '-' + Math.random().toString(36).substring(2, 9),
                userId: currentUserId
            };
            
            // Clear the log display
            document.getElementById('point-log').innerHTML = '<p class="text-sm text-gray-500">No points recorded yet. Hit a point button to start logging!</p>';

            document.getElementById('match-id-display').textContent = matchState.matchId;
            enableButtons();
            showModal();
            updateMatchStatus('New Match Ready. Enter names.');
            render();
        }

        /**
         * Shows the name input modal.
         */
        function showModal() {
            const modal = document.getElementById('modal');
            const p1Input = document.getElementById('p1-input');
            const p2Input = document.getElementById('p2-input');

            // Pre-fill current names
            p1Input.value = matchState.p1Name === 'Player 1' ? '' : matchState.p1Name;
            p2Input.value = matchState.p2Name === 'Player 2' ? '' : matchState.p2Name;

            modal.style.display = 'flex';
        }

        /**
         * Saves the entered names, closes the modal, and saves state to DB.
         */
        window.saveNames = function() {
            try {
                const p1Input = document.getElementById('p1-input').value.trim() || 'Player 1';
                const p2Input = document.getElementById('p2-input').value.trim() || 'Player 2';

                matchState.p1Name = p1Input;
                matchState.p2Name = p2Input;

                console.log("Attempting to hide modal...");
                document.getElementById('modal').style.display = 'none';
                console.log("Modal hide instruction sent. Check if the modal disappeared.");

                updateMatchStatus('Match is Active');
                render();
                // We call saveMatchState() asynchronously at the end.
                saveMatchState();

            } catch (error) {
                console.error("Critical Error in saveNames function:", error);
                updateMatchStatus(`Error starting match: ${error.message}. Check console for details.`, 'match-end');
            }
        }

        /**
         * Disables the score buttons when the match ends or is initializing.
         */
        function disableButtons() {
            document.getElementById('btn-p1').disabled = true;
            document.getElementById('btn-p2').disabled = true;
            document.getElementById('btn-undo').disabled = true;
            document.getElementById('btn-p1').classList.add('opacity-50', 'cursor-not-allowed');
            document.getElementById('btn-p2').classList.add('opacity-50', 'cursor-not-allowed');
        }

        /**
         * Enables the score buttons after authentication/load.
         */
        function enableButtons() {
            document.getElementById('btn-p1').disabled = false;
            document.getElementById('btn-p2').disabled = false;
            document.getElementById('btn-p1').classList.remove('opacity-50', 'cursor-not-allowed');
            document.getElementById('btn-p2').classList.remove('opacity-50', 'cursor-not-allowed');
        }

        // Initialize the app: start firebase connection
        window.onload = function() {
            disableButtons();
            initFirebase();
        };

    </script>
</body>
</html>